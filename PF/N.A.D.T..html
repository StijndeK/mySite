<!DOCTYPE html>
<html>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<!-- title -->
<title>NADT</title>
<!-- icon -->
<link rel="icon" type="image/png" href="../Media/LogoSmall.png">
<!-- stylesheets -->
<link rel="stylesheet" href="https://www.w3schools.com/w3css/4/w3.css">
<link rel="stylesheet" href="../style.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<head>
  <style>
    img {
      width: 100%;
    }
  </style>
</head>

<body>
 
<!-- Navbar (sit on top) -->
<div class="w3-top " >
  <div class="w3-bar" id="myNavbar">
    <a class="w3-bar-item w3-button w3-hover-black w3-hide-medium w3-hide-large w3-right" href="javascript:void(0);" onclick="toggleFunction()" title="Toggle Navigation Menu">
      <i class="fa fa-bars"></i>
    </a>
    <a href="../works.html" class="w3-bar-item w3-button w3-xlarge">BACK</a>
  </div>

  <!-- Navbar on small screens -->
  <div id="navDemo" class="w3-bar-block w3-white w3-hide w3-hide-large w3-hide-medium">
    <a href="../works.html" class="w3-bar-item w3-button" onclick="toggleFunction()">BACK</a>
  </div>
</div>

<!-- HEADER -->
<div class="w3-bar w3-black">
  <div class="w3-bar-item"> <br> </div>
</div>

<video class="page-cover-video-header" autoplay muted loop >
  <source src="../Media/NADT_headerVideo.mp4" type="video/mp4">
</video>

<div class="w3-bar w3-black">
  <div class="w3-bar-item"> <br> </div>
</div>

<!-- page content -->
<div class="w3-container w3-content" style="max-width: 900px; margin-top: 50px">

  <!-- title -->
  <h1> Nonlinear Audiosystems Design Tools </h1>
  <!-- under title -->
  <h4> Audio programming, nonlinear audio design <div class="w3-right"> may 18, 2020 </div></h4>

  <hr>

  <p> 
    <strong> 
      As a game audio designer I am hindered during my creative process, due to the discrepancy between the nonlinearity of my work and the linear character of standard audio production software. 
    </strong>
  </p>

  <div class="row">
    <div class="column">  
      <br>
      <!-- <img class="stack-image" src="../Media/RookeryScreencap1.png"/>
      <img class="stack-image" src="../Media/NADT_Screenshot2.png"/>
      <img class="stack-image" src="../Media/PI.png"/> -->
      <div style="width:95%;height:0px;position:relative;padding-bottom:56.250%;"><iframe src="https://streamable.com/e/q9vrqt?loop=0" frameborder="0" width="100%" height="100%" allowfullscreen style="width:100%;height:100%;position:absolute;left:0px;top:0px;overflow:hidden;"></iframe></div>
    </div>

    <div class="column">    
      <p>
        Standard linear audio production tools offer little to none nonlinear sequencing, transitioning, parameter adaption and probability functionalities. 
        Furthermore, linear sequencers are not optimised to provide a visual representation of nonlinear systems. 
        Current standard middleware solutions are more focussed on optimising implementation and less on tackling the obstructions in the design stage of a project. 
        These issues cause testing and prototyping to take unnecessary long and obscures communication with collaborators. 
        This obstructs the workflow and discourages innovation.
      </p>
    </div>
  </div>

  <p>
    Nonlinear Audiosystems Design Tools or NADT, is a range of experiments in the form of prototypes for tools to tackle these issues. 
    By prototyping various tools to address issues caused by the nonlinearity of video games in relation to the linearity of audio production software, I hope to improve the process of designing and testing nonlinear audiosystems. 
    The project has been created as part of my thesis on <a href="../ToolsforDesigningNonlinearGameAudioSystems.pdf" target="_blank">Tools for Designing Nonlinear Game Audio Systems</a>.
  </p>

  <h3>
    Main issues
  </h3>
  <p>
    The current issues that arise are divisible into 3 general subjects: 
    The inability to quickly test and prototype audio systems with their audio, the lack of overview current standard tools provide (which also hinders communication)
    and the lack of visual and interactive context.
  </p>

  <p>
    With an approach that favours quick testing and prototyping, I hope to approach the problem from multiple angles.
    This should provide a more general sense of what works well and what doesn't, before focussing on specific elements.
    The main disadvantage of this approach however, is that many interesting details will not (yet) be addressed.
  </p>

  <h3>
    Modular 'flexible' tools
  </h3>
  <p>
    To be able to function as a proof of concept on how to tackle the issues, the tools need to be flexible and can't be specific to any one game or phase in game audio.
  </p>
  <p>
    <i>'.. the game industry is undergoing constant change .. . The only solution to this unpredictable situation is granularity--that is , the goal to build a flexible set of tools that are constantly able to update, evolve and adapt'
    </i>  
    - Florian Füsslin, Audio Director at Crytek (Game Audio Programming: Principles and Practices)
  </p>


  <h3>
    Current status
  </h3>

  <p>
    This project is still in progress.
    So far, I have worked on 3 experiments. All of which have reached their research goals, but can be much further explored in the future. 
  </p>


  <div style="padding-bottom: 50px;">
    <p>
      Click bellow to cycle between the different experiments done so far.
    </p>
  <div class="w3-bar w3-border" id="myDIV">
    <a  style="width:33.3%; padding-top: 15px; padding-bottom: 15px; "class="btn w3-bar-item w3-button w3-mobile" onclick="setActive(0)">1. Automatic sound loading</a>
    <a  style="width:33.3%; padding-top: 15px; padding-bottom: 15px;"class="btn w3-bar-item w3-button w3-mobile" onclick="setActive(1)">2. Visual parameter adaption</a>
    <a style="width:33.3%; padding-top: 15px; padding-bottom: 15px;"class="btn w3-bar-item w3-button w3-mobile active" onclick="setActive(2)">3. Procedural sequencing</a>
  </div>
</div>

  <div id="ActiveDiv1">
    <h2> <a href="https://github.com/StijndeK/N.A.D.AutomaticSoundloader"> Automatic sound loading and parsing</a> </h2>

    <p>        
      The first experiment is a Python terminal application, that allows the user to quickly test quantised nonlinear audio systems. 
      The project tackles the disturbance caused by the time and effort spent from creating audio to being able to hear and test it within its nonlinear system (and eventually within the context of the game). 
      Export audio directly into specific folders using specific file and folder names and it will automatically sequence and layer the audio based on the data obtained from the file and folder titles.
    </p>

    <div class="row">
      <div class="column">  
        <p>
          The project tackles the disturbance caused by the time and effort spent from creating audio to being able to hear and test it within its nonlinear system (and eventually within the context of the game). 
          Directly loading the audio with given data about transitions and layering in the file and folder names, allows for quicker testing. 
          The video shows this experiment demonstrated on an early musical concept for Rookery, a game currently being developed. 
          <a href="Rookery.html"> Click here</a> for more information on the project.
        </p>
      </div>

      <div class="column" >    
        <div class="w3-container w3-content w3-center">
          <div style="width:90%;height:0px;position:relative;padding-bottom:72.241%;"><iframe src="https://streamable.com/e/cstiw8?loop=0" frameborder="0" width="100%" height="100%" allowfullscreen style="width:100%;height:100%;position:absolute;left:0px;top:0px;overflow:hidden;"></iframe></div>
        </div>
      </div>
    </div>

    <h3> Quantised synchronisation</h3>
    <p>
      I decided to start with quantised grid-based bar synchronisation, based on the following quote from Colin Walder:
    </p>
    <p> 
      <i>
      'For basic synchronization, I start with bars, beats and grid since it is trivial to prepare the interactive music to support these, and because the are they are the most straightforward to understand in terms of mapping to gameplay.'
      </i>
      (Game Audio Programming: Principles and Practices)
    </p>


    <div class="row">
      <div class="column"> 
        <div class="w3-container w3-content w3-center">
          <img  src="../Media/SN_Exp1Graph.png"/>
        </div> 
      </div>

      <div class="column" >    
        <p>
          The system to be tested with this tool, is based on layers containing different variations. 
          Audio is sequenced on a given bpm and loop length. 
          For every layer a variation is chosen and played. 
          The data obtained from a filename indicates to what variations a variation within a layer can transition. 
          This means that every layer transitions independent of each other. 
          Because of this, every variation of every layer needs to be loopable over each other.
        </p>
      </div>
    </div>

    <h3> File loading </h3>
    <p>
      To add a layer, a folder needs to be created in the ‘Bounces’ folder. The title of every folder should end with an underscore followed by the number of the layer. Within every folder, audiofiles containing variation-loops can be put. A variation-loops filename should start with the number of the variation, followed by its title, followed by the numbers of variations it can transition to, all separated by underscores.
    </p>
    
    <div class="w3-container w3-content w3-center">
      <img  src="../Media/FileLoading.png"/>
    </div>
    <br>

    <h3> Status</h3>


    <p>     
      Quick testing, by directly bouncing the audio with specific titles, saves time. 
      However, the options are still very limited and file names do need to be named very specifically. 
      User input could be completely avoided by obtaining bpm and the amount of beats from the folder or file titles as well. 
      This system is very simple and can only test a specific type of nonlinear sequencing. 
      However, it has achieved its goal in testing this type of approach.
    </p>

    <hr>
    <a href="https://github.com/StijndeK/N.A.D.AutomaticSoundloader" target="blank"><i class="fa fa-github" style="font-size:40px; padding:10px;"></i></a>
    <hr>

  </div>

  <div id="ActiveDiv2">

    <h2> <a href="https://github.com/StijndeK/N.A.D.VisualParameterAdaption"> Visual Parameter Adaption</a> </h2>

    <p>
      VPA is a prototype tool that uses a visual overview and interface along with the automatic file loading functionality carried over from the previous experiment,  
      to look into upgrading the process of prototyping nonlinear systems and improving (interdisciplinary) communication. 
      Because audio is a nonvisual medium and therefore always is experienced linearly, it can prove difficult to explain or fully understand nonlinear audiosystems design.
    </p>
    <div class="row" style="margin-top: 5px;">
      <div class="column">  
        <div style="width:90%;height:0px;position:relative;padding-bottom:66.667%;"><iframe src="https://streamable.com/e/y6rm5e?loop=0" frameborder="0" width="100%" height="100%" allowfullscreen style="width:100%;height:100%;position:absolute;left:0px;top:0px;overflow:hidden;"></iframe></div>      
      </div>

      <div class="column"  >    
        <!-- <div class="w3-container w3-content"> -->
          <p>
          Files are loaded from a given folder location and information on layers and transition-possibilities is obtained from them.
          Layerboxes can be spawned from the Spawner.
          A layerbox holds a layer with all its variations.
          When dragged into the sequencer the layerbox is given a X and Y parameter.
          These parameters can be set to certain values by moving the X and Y sliders.
          The transitions between variations within layers aren't visualised (yet), but behave in the same way as the previous experiment where the numbers at the end of a filename indicate to what variations a variation can transition.
          </p>
        </div>
      <!-- </div> -->
    </div>

    <p>
      As the current prototype is bound to time restrictions and made to quickly test the most important features,
      I have created a mockup showcasing some future possibilities. 
      The mockup shows how components can dynamically be loaded in, based on what is useful for the project. 
      This also makes it easier to add components in the future.
    </p>

    <div class="row" style="margin-top: 5px;">
      <div class="column">  
        <p>
          As visual context is an important part of game audio, a component to load in visual context has been added. 
          In the future I'd like the program to style the entire interface based on input visuals.
          I'd also like to add some simple 'template' games, so that the audio can be tested in its interactive context as well.
          The 'Layer Containers' now show what variation of the layer is being played.
          As oneshots are another important context to test with looping audio, a component to play sound effects has also been added. 
          In the future I'd like to add sidechaining and randomisation (pitch, gain, etc) functionalities.
        </p>
      </div>

      <div class="column"  style="margin-top: 15px;">    
        <div class="w3-container w3-content">
          <div style="width:90%;height:0px;position:relative;padding-bottom:66.543%;"><iframe src="https://streamable.com/e/33jgtx?loop=0" frameborder="0" width="100%" height="100%" allowfullscreen style="width:100%;height:100%;position:absolute;left:0px;top:0px;overflow:hidden;"></iframe></div>
        </div>
      </div>
    </div>



    <h3> <a href="Rookery.html">Project Rookery </a></h3>
    <p>
      The video shows the project used to test a musical concept for project Rookery.
      Rookery is a walking simulator set in the Victorian era in London, currently under development. <a href="Rookery.html"> Click here</a> for more information on the project.
    </p>
    <div class = "w3-center w3-hover-opacity">
      <a href="Rookery.html">
        <img style="padding: 10px" src="../Media/RookScreenshotStreet.jpeg"/>
      </a>
    </div>

    <h3> Systems design </h3>

    <p>
      The current prototype has 4 main components. 
      The Fileloader loads audiofiles and parses information obtained from their names. 
      The Spawner allows the user to spawn Layers containing horizontal loops with variations, that can then be dragged into the Sequencer. 
      The Sequencer checks if certain parameters are checked to see if and what sound needs to be played. 
      The Controller eventually calls the audio.
      Below is a general overview of the current system.
    </p>

    <div class="w3-container w3-content w3-center">
      <img  src="../Media/VASD_Dataflow.png"/>
    </div>

    <h3> Improvements </h3>
    <p>
      As an investigation into using a visual approach to upgrade the process of designing nonlinear audio for games and communicating about them, VPA has achieved its goal.
      However, the project only scratches the surface of nonlinear game audio possibilities and its current version conditions the user quite heavily into using certain techniques.
      Moreover, the current system isn't easily adaptable enough, mainly due to the Unity based 'objectcomponents approach'. 
      This is also one of the reasons for the next (third) experiment completely stepping away from this approach.
    </p>

    <hr>
    <a href="https://github.com/StijndeK/N.A.D.VisualParameterAdaption" target="blank"><i class="fa fa-github" style="font-size:40px; padding:10px;"></i></a>
    <hr>

  </div>

  <div id="ActiveDiv3">
    <h2 id="PI"> <a href="https://github.com/StijndeK/N.A.D.ProcederalAudioSystem"> Procedural audiosystems design and implementation </a> </h2>

    <div class="row">
      <div class="column">  
        <p>
          The latest experiment is a prototype for a framework/tool designed to improve procedural music systems prototyping and implementing. 
          Even though procedural sound design has become somewhat standard in game audio, I find procedural music is still relatively underrepresented. 
          It can be difficult, time consuming and expensive to prototype, test and implement. 
        </p>
      </div>

      <div class="column" >    
        <div class="w3-content w3-container w3-center">
          <div style="width:90%;height:0px;position:relative;padding-bottom:56.250%;"><iframe src="https://streamable.com/e/cw2kjj?loop=0" frameborder="0" width="100%" height="100%" allowfullscreen style="width:100%;height:100%;position:absolute;left:0px;top:0px;overflow:hidden;"></iframe></div>
        </div>
      </div>
    </div>

    <p>
      Because it can be difficult to test, it often is a risk to even attempt procedural music.
      Procedural music won't work well for every game, but because it is the most dynamic form of nonlinear music, I believe it should be easier to try out.
      Games such as Mini Metro and Monkey Island have successfully showcased how procedural music can exponentially elevate an entire game.
    </p>
    <p>
      PAS allows for quick testing and implementing procedural music, using a sample-based sequencer. 
      
      The automatic file loading functionally has again been carried over from the first experiment. 

      This project shies away from a visual approach, to put more focus on quick implementation and building a general modular framework.
      PAS's more universal approach and lack of visuals makes it an easy library to implement in any game.
      This does however lead to the programmer also having to be the composer and vice versa.
    </p>

    <h3>Procedural Imagination</h3>
    <p>
    PAS is made as a general framework/tool, but is also used for and tested on 'Procedural Imagination'. 
    A procedurally generated game world that dynamically responds to the player's actions.
    Currently being developed by <a href="http://josienvos.nl/" target="blank">Josien Vos</a>.
  </p>
    <div class="w3-center">
      <img style="padding:10px;" src="../Media/PI.png"/>
      <!-- <img style="padding:10px" src="../Media/PI2.png"/> -->
    </div>

    <h3>
      Systems design
    </h3>

    <p>
      External gamedata is used to trigger and generate Cycles. These Cycles set audio parameters for Layers. Layers hold audiofiles and data on when and how to play them. The Sequencer receives ticks from the Clock and checks variables within Layers to trigger audiofiles. 
    </p>

    <div class = "w3-center">
      <img onclick="document.getElementById('id01').style.display='block'" class = "w3-hover-opacity" style="width:90%;" src="../Media/PI_Diagram.png"/>
    </div>

  <div id="id01" class="w3-modal">
    <div class="w3-modal-content">
      <div class="w3-container" >
        <span onclick="document.getElementById('id01').style.display='none'" class="w3-button w3-display-topright">&times;</span>
        <div class="w3-center">
          <img width = 80% style="padding: 20px;" src="../Media/PI_Diagram.png"/>
        </div>
      </div>
    </div>
  </div>

    <p>
      For a more intricate audiosystem, checking what to play and calling the sounds should be split to reduce the risk of delays.
      <a href="../Media/PI_DataflowWhite.png"target="_blank" >Click here</a> for a more in depth dataflow overview.
    </p>

    <h5>Layers</h5>
      <p>The loaded audio is divided into vertical layers, to be played independently or over each other. A layer can consist of vertical loops or oneshot sound effects. A layer holds data on how, when and what variation to play.
    </p>

    <h5>Generating audiodata</h5>
    <p>Layers contain 'musical values', among which a rhythm and a tonal layer. These rhythms and melodies are used in the sequencer to check when and what file to play. The rhythm calls on what ticks audio needs to be played. The tonal layer decides what notes need to be played, based on the Layertype (melody, countermelody, chord, percussion, etc) and the available samples within the layer.
    </p>

    <h5>Cycles</h5>
    <div class="row">
      <div class="column">  
        <p> A Cycle holds Parameters, that hold values to adjust, values to adjust to and what layers to adjust. Using a Cycle is the only way to adapt audiodata. Cycles can be triggered from game events using a AdaptionMoment or from the sequencer, using a CycleTimer. A DynamicCycle only sets the on/off value of layers. Using a CycleTimer the DynamicCycle can create a natural sounding buildup. For now this buildup is mostly random. In the future specific dynamic structures could be given and/or influenced by external parameters.
          This system is build so that any one parameter or game event can easily be linked to multiple aspects of audiodata. This prevents conditioning the user into using certain systems.
        </p>
      </div>

      <div class="column" >    
        <div class="w3-content w3-container w3-center">
          <img style="width:90%;" src="../Media/PI_CycleDataflow.png"/>
        </div>
      </div>
    </div>

    <h3>
      Unity & C#
    </h3>
    <p>
      To allow for quick testing and implementing, PAS is written in C# for Unity. However, because PAS should serve as a general framework, PAS moves away from a component based Unity hierarchy and uses little to none Unity-specific elements.
      Only the ProceduralAudio component needs to be placed in a scene.
    </p>

    <div class="w3-center">
      <!-- <img style="padding:10px;" src="../Media/PI.png"/> -->
      <img style="padding:10px" src="../Media/PI2.png"/>
    </div>

    <h3>
      Improvements
    </h3>

    <p>
      The most important goal for this experiment is to investigate improving the audiosystems designing process and encouraging experimentation by removing the obstructions in the workflow.
      The current MVP for this project have been achieved. However, the project could be further developed indefinitely. 
      Because the focus lies on quick prototyping a lot of interesting features have been overlooked, 
      the most important features I'd like to add in the near future are:

      <ul style="text-transform: lowercase;">
        <li> easily being able to adapt every single parameter. Probably by converting to C++ to use pointers.</li>
        <li> (adapative) DSP </li>
        <li> variation generation </li>
        <li> AI </li>
        <li> priority system </li>
        <li> more eleborate dynamics system (creating sentences) </li>
        <li> probability </li>
        <li> more info from input files </li>
        <li> more intricate algorythms to generate data from </li>
        <li> a visual respresentation and UI such as in N.A.D Visual Parameter Adaption in Unity </li>
      </ul>
      
    </p>
    <hr>
    <a href="https://github.com/StijndeK/N.A.D.ProcederalAudioSystem" target="blank"><i class="fa fa-github" style="font-size:40px; padding:10px;"></i></a>
    <hr>

  </div>

</div>

<!-- footer -->
<footer style="color: white; background-color: black; margin-top: 100px; padding: 50px;" id="contact">
  <div class="w3-container w3-content" style="max-width: 700px;">

    <div class="row" style="margin-top: 40px;">

      <div class="columnAdaptive middle">  
        <a href="https://www.linkedin.com/in/stijn-koning-de-196aab133/"><i class="fa fa-linkedin" style="font-size:40px; padding:10px;"></i></a>
        <a href="https://www.instagram.com/dekoningstijn/"><i class="fa fa-instagram" style="font-size:40px; padding:10px"></i></a>
        <a href="https://github.com/StijndeK"><i class="fa fa-github" style="font-size:40px; padding:10px;"></i></a>
        <a href="https://soundcloud.com/stijn-de-koning"><i class="fa fa-soundcloud" style="font-size:30px; padding:10px;"></i></a>
        <p> Copyright © Stijn de Koning, 2020 </p>
      </div>

      <div class="columnAdaptive middle">  
        <h6>
          <i class="fa fa-envelope" ></i> sdk.stijn@gmail.com <br>
          <i class="fa fa-globe"></i> Amsterdam, Netherlands <br>
          <i class="fa fa-university"></i> Music & Technology, University of the Arts Utrecht
        </h6>
      </div>

      <div class="columnAdaptive left">  
        <img style="width:90%;" src="../Media/LogoSmall.png"/>
      </div>

    </div>
  </div>
</footer>

<script>
  var header = document.getElementById("myDIV");
  var btns = header.getElementsByClassName("btn");
  for (var i = 0; i < btns.length; i++) {
    btns[i].addEventListener("click", function() {
    var current = document.getElementsByClassName("active");
    current[0].className = current[0].className.replace(" active", "");
    this.className += " active";
    });
  }

  window.onload = setActive(2);

  function setActive(int) {
  var x = [document.getElementById("ActiveDiv1"), document.getElementById("ActiveDiv2"), document.getElementById("ActiveDiv3")];
  x[int].style.display = "block";
  for(var object of x){
    if (object != x[int]){
      object.style.display = "none";
    }
  }
}
</script>
</body>
</html>
